<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ceefaxstation</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      html, body { height: 100%; margin: 0; }
      #app { display: grid; grid-template-columns: 1fr 360px; height: 100%; }
      #map { height: 100%; }
      #side { border-left: 1px solid #222; padding: 12px; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background: #0b0b0b; color: #f3f3f3; overflow: auto; display: flex; flex-direction: column; }
      .row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
      select, button, input { padding: 6px 8px; }
      .muted { opacity: 0.75; font-size: 12px; }
      .box { border: 1px solid #333; padding: 8px; border-radius: 6px; margin-top: 10px; background: #111; }
      .tag { display: inline-block; padding: 2px 6px; border: 1px solid #444; border-radius: 999px; margin: 2px 4px 2px 0; font-size: 12px; }
      a { color: #ffd34d; }

      /* Sidebar logo (matches page 000 text-art) */
      .logo-wrap {
        display: flex;
        justify-content: center;
        margin: 0 0 8px 0;
      }
      .logo {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        white-space: pre;
        line-height: 1.05;
        color: #ffd34d;
        margin: 0;
        padding: 6px 8px;
        border: 1px solid #2a2a2a;
        border-radius: 6px;
        background: #0f0f0f;
        width: fit-content;
      }

      /* Simple legend (matches current map styling) */
      .legend { display: grid; grid-template-columns: 1fr; gap: 8px; margin-top: 8px; }
      .legend-item { display: flex; align-items: center; justify-content: space-between; border: 1px solid #2a2a2a; border-radius: 6px; padding: 6px 8px; background: #0f0f0f; }
      .swatch { width: 46px; height: 18px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.25); }
      .sw-yellow { background: rgba(255,211,77,0.85); }
      .sw-blue { background: rgba(74,163,255,0.75); }
      .sw-green { background: rgba(46,204,113,0.80); }

      /* Improve click affordance on map paths */
      .leaflet-interactive { cursor: pointer; }

      /* Link detail table */
      table { width: 100%; border-collapse: collapse; }
      th, td { border-bottom: 1px solid #2a2a2a; padding: 6px 6px; font-size: 13px; }
      th { text-align: left; font-size: 12px; opacity: 0.85; }
      .cell-center { text-align: center; }
      .boxmark {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 18px;
        height: 18px;
        border-radius: 3px;
        border: 1px solid rgba(255,255,255,0.35);
        font-weight: 800;
        font-size: 12px;
        line-height: 18px;
        user-select: none;
      }
      .box-ok { background: rgba(255,211,77,0.22); color: #ffd34d; border-color: rgba(255,211,77,0.55); }
      .box-bad { background: rgba(74,163,255,0.18); color: #4aa3ff; border-color: rgba(74,163,255,0.55); }

      .footer {
        margin-top: auto;
        padding-top: 12px;
        font-size: 12px;
        opacity: 0.85;
      }
      .footer .line { margin-top: 4px; }

      /* Alpha/Development notice */
      .alpha-banner {
        background: linear-gradient(135deg, rgba(255, 100, 0, 0.2), rgba(255, 150, 0, 0.15));
        border: 2px solid rgba(255, 150, 0, 0.6);
        border-radius: 6px;
        padding: 10px 12px;
        margin: 0 0 12px 0;
        text-align: center;
        font-size: 13px;
        font-weight: 600;
        color: #ffaa44;
        box-shadow: 0 0 12px rgba(255, 150, 0, 0.2);
      }
      .alpha-banner .alpha-label {
        display: inline-block;
        background: rgba(255, 150, 0, 0.25);
        padding: 2px 8px;
        border-radius: 4px;
        margin-right: 6px;
        font-size: 11px;
        font-weight: 700;
        letter-spacing: 0.5px;
        text-transform: uppercase;
      }

    </style>
  </head>
  <body>
    <div id="app">
      <div id="map"></div>
      <div id="side">
        <div class="logo-wrap">
          <pre class="logo">  â–‘â–ˆâ–€â–€â–‘â–ˆâ–€â–€â–‘â–ˆâ–€â–€â–‘â–ˆâ–€â–€â–‘â–ˆâ–€â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–‘
  â–‘â–ˆâ–‘â–‘â–‘â–ˆâ–€â–€â–‘â–ˆâ–€â–€â–‘â–ˆâ–€â–€â–‘â–ˆâ–€â–ˆâ–‘â–„â–€â–„â–‘â–‘
  â–‘â–€â–€â–€â–‘â–€â–€â–€â–‘â–€â–€â–€â–‘â–€â–‘â–‘â–‘â–€â–‘â–€â–‘â–€â–‘â–€â–‘â–‘
â–‘â–ˆâ–€â–€â–‘â–€â–ˆâ–€â–‘â–ˆâ–€â–ˆâ–‘â–€â–ˆâ–€â–‘â–€â–ˆâ–€â–‘â–ˆâ–€â–ˆâ–‘â–ˆâ–€â–ˆ
â–‘â–€â–€â–ˆâ–‘â–‘â–ˆâ–‘â–‘â–ˆâ–€â–ˆâ–‘â–‘â–ˆâ–‘â–‘â–‘â–ˆâ–‘â–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆ
â–‘â–€â–€â–€â–‘â–‘â–€â–‘â–‘â–€â–‘â–€â–‘â–‘â–€â–‘â–‘â–€â–€â–€â–‘â–€â–€â–€â–‘â–€â–‘â–€</pre>
        </div>
        <div class="alpha-banner">
          <span class="alpha-label">Alpha</span>
          Site in active development â€” features may change
        </div>
        <div class="row">
          <label for="range">Window</label>
          <select id="range">
            <option value="24h">Last 24 hours</option>
            <option value="7d">Last 7 days</option>
            <option value="30d">Last 30 days</option>
          </select>
          <button id="refresh">Refresh</button>
        </div>
        <div class="muted" id="status">Connectingâ€¦</div>

        <div class="box">
          <div><strong>Click a line</strong> to see pages TX and RX status.</div>
          <div class="muted">Stations require Maidenhead (grid) to appear on the map.</div>
        </div>

        <div class="box" style="margin-top:12px;">
          <div><a href="/changelog" style="text-decoration:underline; font-weight:600;">ðŸ“‹ View Changelog</a></div>
          <div class="muted" style="margin-top:4px;">See what's new in version <span id="versionDisplayInline"></span></div>
        </div>

        <div class="box">
          <div><strong>Legend</strong></div>
          <div class="legend">
            <div class="legend-item"><span>Transmitting station (TX)</span><span class="swatch sw-green"></span></div>
            <div class="legend-item"><span>Receiving OK (all pages)</span><span class="swatch sw-yellow"></span></div>
            <div class="legend-item"><span>Receiving partial (missing pages)</span><span class="swatch sw-blue"></span></div>
          </div>
          <div class="muted" style="margin-top:8px;">
            Partial stations render as a diagonal split (top-left = station color, bottom-right = blue).
            Links are yellow when complete and blue when incomplete.
          </div>
        </div>

        <div class="box" id="detail" style="display:none;">
          <div class="row">
            <strong id="linkTitle"></strong>
          </div>
          <div class="muted" id="linkMeta"></div>
          <div class="muted" id="linkDistance" style="margin-top:6px;"></div>
          <div style="margin-top:10px;">
            <table>
              <thead>
                <tr>
                  <th>Page</th>
                  <th class="cell-center">TX</th>
                  <th class="cell-center">RX</th>
                  <th>Freq</th>
                  <th>dB</th>
                  <th>Age</th>
                </tr>
              </thead>
              <tbody id="linkTable"></tbody>
            </table>
          </div>
        </div>

        <div class="footer">
          <div class="line"><a href="https://github.com/thaum-labs/ceefax_station" target="_blank" rel="noopener noreferrer">Download Ceefax Station</a></div>
          <div class="line"><a href="/changelog" style="text-decoration:underline;">View Changelog</a> Â· <span id="versionDisplay"></span></div>
          <div class="line">Created by <strong>M7TJF</strong> Â· Ceefax Station Â© <span id="year"></span></div>
        </div>
      </div>
    </div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script>
      const map = L.map('map', { worldCopyJump: true }).setView([54.5, -2.5], 6);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      const rangeSel = document.getElementById('range');
      const refreshBtn = document.getElementById('refresh');
      const statusEl = document.getElementById('status');
      const detailBox = document.getElementById('detail');
      const linkTitle = document.getElementById('linkTitle');
      const linkMeta = document.getElementById('linkMeta');
      const linkDistance = document.getElementById('linkDistance');
      const linkTable = document.getElementById('linkTable');

      let stationMarkers = new Map(); // callsign -> {layers:[]}
      let linkLayers = [];
      let currentRange = rangeSel.value;

      // Palette (matches current design)
      const COLOR = {
        ok: '#ffd34d',     // yellow
        warn: '#4aa3ff',   // blue
        tx: '#2ecc71'      // green
      };

      // Animated "flow" links (GridTracker-ish direction indicator)
      let flowLinks = []; // { el, offset, speed }
      let flowRaf = null;

      function _getPathElement(polyline) {
        // Leaflet >=1.9 supports getElement(); fallback to internal _path.
        if (polyline && typeof polyline.getElement === 'function') return polyline.getElement();
        return polyline && polyline._path ? polyline._path : null;
      }

      function startFlowLoop() {
        if (flowRaf) return;
        const tick = () => {
          for (const f of flowLinks) {
            if (!f.el) continue;
            // Negative dashoffset makes the dash pattern move along the path direction (start -> end).
            f.offset = (f.offset - f.speed) % 1000;
            f.el.style.strokeDashoffset = String(f.offset);
          }
          flowRaf = requestAnimationFrame(tick);
        };
        flowRaf = requestAnimationFrame(tick);
      }

      function stopFlowLoopIfIdle() {
        if (flowLinks.length !== 0) return;
        if (flowRaf) {
          cancelAnimationFrame(flowRaf);
          flowRaf = null;
        }
      }

      function clearLinks() {
        for (const l of linkLayers) map.removeLayer(l);
        linkLayers = [];
        flowLinks = [];
        stopFlowLoopIfIdle();
      }

      function setTags(el, pages) {
        el.innerHTML = '';
        if (!pages || pages.length === 0) {
          el.innerHTML = '<span class="muted">None</span>';
          return;
        }
        for (const p of pages) {
          const s = document.createElement('span');
          s.className = 'tag';
          s.textContent = p;
          el.appendChild(s);
        }
      }

      async function fetchMap() {
        currentRange = rangeSel.value;
        statusEl.textContent = 'Loadingâ€¦';
        const resp = await fetch(`/api/map?range=${encodeURIComponent(currentRange)}`);
        const data = await resp.json();
        renderMap(data);
        statusEl.textContent = `Updated. Range=${data.range} (since ${data.since_utc})`;
      }

      function renderMap(data) {
        // Stations
        const seen = new Set();
        for (const s of data.stations) {
          // Require bbox (grid) to draw a rectangle.
          if (!s.bbox || !s.bbox.sw || !s.bbox.ne) continue;
          seen.add(s.callsign);
          if (!stationMarkers.has(s.callsign)) {
            const sw = [s.bbox.sw.lat, s.bbox.sw.lon];
            const ne = [s.bbox.ne.lat, s.bbox.ne.lon];

            const layers = [];
            const isTx = !!s.is_tx;
            const isNone = (s.status === 'none');
            const primary = isNone ? COLOR.warn : (isTx ? COLOR.tx : COLOR.ok); // blue if not receiving, else TX green / yellow
            const secondary = COLOR.warn; // blue for missing/links
            const outline = primary;

            if (s.status === 'partial') {
              // Two triangles: top-left yellow, bottom-right blue
              const nw = [ne[0], sw[1]];
              const se = [sw[0], ne[1]];

              // Less transparency (more opaque) than before.
              const tri1 = L.polygon([nw, ne, sw], { color: primary, weight: 1, fillColor: primary, fillOpacity: 0.55 });
              const tri2 = L.polygon([sw, ne, se], { color: secondary, weight: 1, fillColor: secondary, fillOpacity: 0.40 });
              const box = L.rectangle([sw, ne], { color: outline, weight: 2, fillOpacity: 0 });
              const diag = L.polyline([nw, se], { color: outline, weight: 1, opacity: 0.95 });
              layers.push(tri1, tri2, box, diag);
            } else {
              // Less transparency (more opaque) than before.
              const rect = L.rectangle([sw, ne], { color: outline, weight: 2, fillColor: primary, fillOpacity: 0.40 });
              layers.push(rect);
            }

            for (const l of layers) l.addTo(map);

            const role = isTx ? 'TX' : ((s.is_rx) ? 'RX' : 'RX (none)');
            const gridDisplay = s.grid ? ` (${s.grid})` : '';
            const popupHtml = `<b>${s.callsign}${gridDisplay}</b><br/>Grid: ${s.grid || '-'}<br/>Role: ${role}<br/>Status: ${s.status || '-'}<br/><span class="muted">Last seen: ${s.last_seen_utc || '-'}</span>`;
            for (const l of layers) l.bindPopup(popupHtml);
            for (const l of layers) l.bindTooltip(`${s.callsign}${gridDisplay}`, { sticky: true });

            stationMarkers.set(s.callsign, { layers });
          }
        }
        for (const [cs, obj] of stationMarkers.entries()) {
          if (!seen.has(cs)) {
            for (const l of (obj.layers || [])) map.removeLayer(l);
            stationMarkers.delete(cs);
          }
        }

        // Links
        clearLinks();
        const byCall = new Map(data.stations.map(s => [s.callsign, s]));
        for (const l of data.links) {
          const tx = byCall.get(l.tx_callsign);
          const rx = byCall.get(l.rx_callsign);
          if (!tx || !rx || !tx.bbox || !rx.bbox) continue;
          const txSw = [tx.bbox.sw.lat, tx.bbox.sw.lon];
          const txNe = [tx.bbox.ne.lat, tx.bbox.ne.lon];
          const rxSw = [rx.bbox.sw.lat, rx.bbox.sw.lon];
          const rxNe = [rx.bbox.ne.lat, rx.bbox.ne.lon];
          const txC = [(txSw[0] + txNe[0]) / 2, (txSw[1] + txNe[1]) / 2];
          const rxC = [(rxSw[0] + rxNe[0]) / 2, (rxSw[1] + rxNe[1]) / 2];

          const weight = Math.min(8, 1 + Math.log10(1 + (l.rx_pages_ok_unique || 0)) * 2);
          // Links: yellow if complete, blue if incomplete.
          const lineColor = (l.complete ? COLOR.ok : COLOR.warn);
          // Wide invisible hit-area line for easier clicking/hovering.
          const hit = L.polyline([txC, rxC], {
            color: '#000',
            opacity: 0.0,
            weight: Math.max(18, weight + 14),
            interactive: true
          });

          const poly = L.polyline([txC, rxC], {
            color: lineColor,
            weight,
            opacity: 0.85,
            dashArray: '10 14' // animated later via dashoffset
          });

          const onClick = () => showLinkDetail(l.tx_callsign, l.rx_callsign);
          hit.on('click', onClick);
          poly.on('click', onClick);

          const total = (l.tx_pages_unique || 0);
          const txGrid = tx && tx.grid ? ` (${tx.grid})` : '';
          const rxGrid = rx && rx.grid ? ` (${rx.grid})` : '';
          const tip = `${l.tx_callsign}${txGrid} â†’ ${l.rx_callsign}${rxGrid} (${l.rx_pages_ok_unique || 0}/${total} pages ok)`;
          hit.bindTooltip(tip, { sticky: true });
          poly.bindTooltip(tip, { sticky: true });

          hit.addTo(map);
          poly.addTo(map);
          linkLayers.push(hit, poly);

          // Enable animated flow (TX -> RX) once Leaflet has created the SVG path.
          setTimeout(() => {
            const el = _getPathElement(poly);
            if (!el) return;
            el.style.strokeLinecap = 'round';
            // Speed scales slightly with link weight so "stronger" links look more lively.
            // Slow down animation by 50% (compared to initial implementation).
            const spd = Math.max(0.3, Math.min(1.2, (weight / 3) * 0.5));
            flowLinks.push({ el, offset: 0, speed: spd });
            startFlowLoop();
          }, 0);
        }
      }

      async function showLinkDetail(tx, rx) {
        const resp = await fetch(`/api/link?tx=${encodeURIComponent(tx)}&rx=${encodeURIComponent(rx)}&range=${encodeURIComponent(currentRange)}`);
        const d = await resp.json();
        detailBox.style.display = '';
        const txGrid = d.tx_grid ? ` (${d.tx_grid})` : '';
        const rxGrid = d.rx_grid ? ` (${d.rx_grid})` : '';
        linkTitle.textContent = `${d.tx_callsign}${txGrid} â†’ ${d.rx_callsign}${rxGrid}`;
        linkMeta.textContent = `Range=${d.range} (since ${d.since_utc})`;

        // Distance
        if (d.distance_km != null && d.distance_mi != null) {
          const km = Number(d.distance_km);
          const mi = Number(d.distance_mi);
          linkDistance.textContent = `Distance: ${km.toFixed(1)} km / ${mi.toFixed(1)} mi`;
        } else {
          linkDistance.textContent = '';
        }

        const rows = Array.isArray(d.rows) ? d.rows : [];
        linkTable.innerHTML = '';
        if (rows.length === 0) {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td colspan="6" class="muted">No pages in this window.</td>`;
          linkTable.appendChild(tr);
          return;
        }

        function fmtAge(sec) {
          const s = Math.max(0, Math.floor(sec || 0));
          if (s < 60) return `${s}s`;
          const m = Math.floor(s / 60);
          if (m < 60) return `${m}m`;
          const h = Math.floor(m / 60);
          if (h < 48) return `${h}h`;
          const d = Math.floor(h / 24);
          return `${d}d`;
        }

        function box(ok) {
          if (ok) return `<span class="boxmark box-ok">âœ“</span>`;
          return `<span class="boxmark box-bad">âœ—</span>`;
        }

        for (const r of rows) {
          const page = r.page_id || '-';
          const txOk = !!r.tx;
          const rxOk = !!r.rx_ok;
          const freq = r.frequency || '-';
          const db = (r.rx_db == null ? '-' : `${Number(r.rx_db).toFixed(1)}`);
          const age = fmtAge(r.age_s);
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${page}</td>
            <td class="cell-center">${box(txOk)}</td>
            <td class="cell-center">${box(rxOk)}</td>
            <td>${freq}</td>
            <td>${db}</td>
            <td>${age}</td>
          `;
          linkTable.appendChild(tr);
        }
      }

      refreshBtn.addEventListener('click', fetchMap);
      rangeSel.addEventListener('change', fetchMap);

      // Live updates via WebSocket (best-effort).
      function connectWS() {
        const proto = location.protocol === 'https:' ? 'wss' : 'ws';
        const ws = new WebSocket(`${proto}://${location.host}/ws`);
        ws.onopen = () => { statusEl.textContent = 'Live connected'; };
        ws.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            if (msg.type === 'ingested') fetchMap();
          } catch {}
        };
        ws.onclose = () => {
          statusEl.textContent = 'Live disconnected; retryingâ€¦';
          setTimeout(connectWS, 1500);
        };
      }

      fetchMap();
      connectWS();

      // Footer year
      document.getElementById('year').textContent = String(new Date().getFullYear());

      // Load version on page load
      const versionDisplay = document.getElementById('versionDisplay');
      const versionDisplayInline = document.getElementById('versionDisplayInline');
      (async () => {
        try {
          const res = await fetch('/api/version');
          const data = await res.json();
          if (data.version && data.version !== 'unknown') {
            const version = data.version;
            const stage = version.includes('-alpha') ? 'alpha' : 
                         version.includes('-beta') ? 'beta' : 'release';
            const versionText = `v${version}${stage !== 'release' ? ` (${stage})` : ''}`;
            versionDisplay.textContent = versionText;
            if (versionDisplayInline) {
              versionDisplayInline.textContent = versionText;
            }
          }
        } catch (err) {
          console.error('Failed to load version:', err);
        }
      })();
    </script>
  </body>
</html>


